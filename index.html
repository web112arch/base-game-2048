import axios from "axios";
import config, { logConfig } from "./config";

// =====================
// Config
// =====================
const API_BASE_URL = config?.api?.baseUrl || "";
logConfig?.();

// =====================
// Axios instance
// =====================
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 20000,
  headers: { "Content-Type": "application/json" },
  withCredentials: true,
});

// Always send cookies
apiClient.interceptors.request.use(
  (requestConfig) => {
    requestConfig.withCredentials = true;
    return requestConfig;
  },
  (error) => Promise.reject(error)
);

// =====================
// Helpers (modernized)
// =====================
const ok = (data) => ({ success: true, data });
const fail = (error) => ({ success: false, error: error || "Unknown error occurred" });

/**
 * Accepts either:
 * - axios response (has .data)
 * - raw data object
 */
const handleApiResponse = (resOrData) => {
  if (resOrData && typeof resOrData === "object" && "data" in resOrData) {
    return ok(resOrData.data);
  }
  return ok(resOrData);
};

const handleApiError = (error) => {
  console.error("API request failed:", error);

  // axios error format
  const serverError = error?.response?.data?.error;
  if (serverError) return fail(serverError);

  // message fallback
  if (error?.message) return fail(error.message);

  return fail("Unknown error occurred");
};

/**
 * Wrapper to remove repetitive try/catch
 * Usage: return api(() => apiClient.get("/path"))
 */
const api = async (fn) => {
  try {
    const res = await fn();
    return handleApiResponse(res);
  } catch (err) {
    return handleApiError(err);
  }
};

// =====================
// Auth check debounce
// =====================
let authCheckPromise = null;
let lastAuthCheck = 0;
let lastAuthResult = null;
const AUTH_CHECK_DEBOUNCE = 2000;

// =====================
// Response interceptor (auth)
// =====================
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error?.response?.status !== 401) return Promise.reject(error);

    const url = error?.config?.url || "";

    // Auth check: expected for anonymous
    if (url.includes("/auth/check")) {
      console.log("ðŸ” Auth check returned 401 - user is anonymous");
      return Promise.reject(new Error("Not authenticated"));
    }

    // Prevent multiple logout calls
    if (typeof window !== "undefined" && sessionStorage.getItem("logout_in_progress")) {
      console.log("ðŸ” Logout already in progress, skipping");
      return Promise.reject(new Error("Authentication expired"));
    }

    // Token exchange should fail silently + cleanup
    if (url.includes("/auth/exchange")) {
      console.log("ðŸ” Token exchange failed - clearing stored tokens");
      if (typeof window !== "undefined") {
        sessionStorage.setItem("logout_in_progress", "true");

        try {
          await apiClient.post("/auth/logout");
        } catch (_) {
          // ignore
        }

        // Be surgical: don't nuke all storage
        localStorage.removeItem("supabase.auth.token");
        sessionStorage.removeItem("logout_in_progress"); // allow future sessions
      }
      return Promise.reject(new Error("Token exchange failed"));
    }

    // Default: reject and let UI handle
    console.log("ðŸ” API returned 401 for endpoint:", url);
    return Promise.reject(new Error("Not authenticated"));
  }
);

// =====================
// Auth utils
// =====================
export const authUtils = {
  isAuthenticated: async () => {
    const now = Date.now();

    if (authCheckPromise && now - lastAuthCheck < AUTH_CHECK_DEBOUNCE) {
      console.log("ðŸ”„ Using cached auth check result");
      return authCheckPromise;
    }

    if (lastAuthResult === false && now - lastAuthCheck < 500) {
      console.log("ðŸ”„ Using recent false auth result");
      return false;
    }

    authCheckPromise = (async () => {
      try {
        lastAuthCheck = now;
        console.log("ðŸ” Making new auth check request");
        const res = await apiClient.get("/auth/check");
        const result = res.status === 200 && res.data?.success === true;
        lastAuthResult = result;
        return result;
      } catch (err) {
        if (err?.response?.status === 401) {
          lastAuthResult = false;
          return false;
        }
        console.error("âŒ Auth check failed:", err);
        lastAuthResult = false;
        return false;
      } finally {
        setTimeout(() => {
          authCheckPromise = null;
        }, AUTH_CHECK_DEBOUNCE);
      }
    })();

    return authCheckPromise;
  },

  exchangeToken: (supabaseToken) =>
    api(() => apiClient.post("/auth/exchange", { token: supabaseToken })),

  logout: async () => {
    try {
      await apiClient.post("/auth/logout");
      console.log("âœ… Logged out successfully");
      return true;
    } catch (err) {
      console.error("âŒ Logout failed:", err);
      return false;
    }
  },
};

// =====================
// Game API
// =====================
export const gameApi = {
  coinflip: {
    getConfig: () => api(() => apiClient.get("/coinflip/config")),
    createGame: (data) => api(() => apiClient.post("/coinflip/create", data)),
    joinGame: (gameId, data) => api(() => apiClient.post(`/coinflip/game/${gameId}/join`, data)),
    getGameState: (gameId) => api(() => apiClient.get(`/coinflip/game/${gameId}`)),
    getPublicGameState: (gameId) => api(() => apiClient.get(`/coinflip/game/${gameId}/public`)),
    getPlayerGames: () => api(() => apiClient.get("/coinflip/games")),
    getUserGames: (params = {}) => api(() => apiClient.get("/coinflip/my-games", { params })),
    getRecentFlips: ({ limit = 10 } = {}) => api(() => apiClient.get("/coinflip/recent", { params: { limit } })),
    getOnlinePlayers: () => api(() => apiClient.get("/coinflip/players")),
    getPlayerStatistics: () => api(() => apiClient.get("/coinflip/statistics")),
    cancelGame: (gameId) => api(() => apiClient.delete(`/coinflip/game/${gameId}`)),
    verifyGame: (data) => api(() => apiClient.post("/coinflip/verify", data)),
  },

  crash: {
    getConfig: () => api(() => apiClient.get("/crash/config")),
    placeBet: (data) => api(() => apiClient.post("/crash/bet", data)),
    cashOut: () => api(() => apiClient.post("/crash/cashout")),
    getCurrentGame: () => api(() => apiClient.get("/crash/current")),
    getGameHistory: ({ limit = 10 } = {}) => api(() => apiClient.get("/crash/history", { params: { limit } })),
    getPlayerBets: () => api(() => apiClient.get("/crash/bets")),
    getPlayerStatistics: () => api(() => apiClient.get("/crash/statistics")),
    getPlayerGames: () => api(() => apiClient.get("/crash/games")),
    getUserGames: (params = {}) => api(() => apiClient.get("/crash/user-games", { params })),
    getHistory: (params = {}) => api(() => apiClient.get("/crash/history", { params })),
    getStats: () => api(() => apiClient.get("/crash/stats")),
    verifyGame: (data) => api(() => apiClient.post("/crash/verify", data)),
  },

  roulette: {
    getCurrentGame: () => api(() => apiClient.get("/roulette/current")),
    placeBet: (betAmount, betType) => api(() => apiClient.post("/roulette/bet", { betAmount, betType })),
    getHistory: (params = {}) => api(() => apiClient.get("/roulette/history", { params })),
    getStats: () => api(() => apiClient.get("/roulette/stats")),
    getUserGames: (params = {}) => api(() => apiClient.get("/roulette/my-games", { params })),
    verifyGame: (data) => api(() => apiClient.post("/roulette/verify", data)),
  },

  mine: {
    getConfig: () => api(() => apiClient.get("/mine/config")),
    createGame: (data) => api(() => apiClient.post("/mine/create", data)),
    getGameState: (gameId) => api(() => apiClient.get(`/mine/game/${gameId}`)),
    getPublicGameState: (gameId) => api(() => apiClient.get(`/mine/game/${gameId}/public`)),
    getPlayerGames: () => api(() => apiClient.get("/mine/games")),
    deleteGame: (gameId) => api(() => apiClient.delete(`/mine/game/${gameId}`)),
    cashOut: (gameId) => api(() => apiClient.post(`/mine/game/${gameId}/cashout`)),
    getHistory: (params = {}) => api(() => apiClient.get("/mine/history", { params })),
    getStats: () => api(() => apiClient.get("/mine/stats")),
    getIncompleteGames: () => api(() => apiClient.get("/mine/incomplete")),
    verifyGame: (data) => api(() => apiClient.post("/mine/verify", data)),
  },

  transaction: {
    getHistory: (params = {}) => api(() => apiClient.get("/transaction/history-page", { params })),
    getStats: () => api(() => apiClient.get("/transaction/stats-page")),
    getTransactionByRef: (ref) => api(() => apiClient.get(`/transaction/ref/${ref}`)),
  },

  user: {
    getStatistics: () => api(() => apiClient.get("/user/statistics")),
    getProfile: () => api(() => apiClient.get("/user/profile")),
    updateProfile: (data) => api(() => apiClient.put("/user/profile", data)),

    uploadAvatar: async (formData) => {
      try {
        const uploadResponse = await fetch("/api/upload-avatar", {
          method: "POST",
          body: formData,
          credentials: "include",
        });

        if (!uploadResponse.ok) throw new Error("Failed to upload file to Pinata");

        const uploadResult = await uploadResponse.json();
        const avatar = uploadResult?.data?.avatar;

        if (!uploadResult?.success || !avatar) throw new Error("Failed to get IPFS URL from upload");

        return api(() => apiClient.put("/user/profile", { avatar }));
      } catch (err) {
        return handleApiError(err);
      }
    },

    regenerateSeed: () => api(() => apiClient.post("/user/regenerate-seed")),
  },

  admin: {
    getCronStatus: () => api(() => apiClient.get("/cron/status")),
    triggerChatCleanup: () => api(() => apiClient.post("/cron/trigger-chat-cleanup")),
  },

  chat: {
    getMessages: ({ room = "default", page = 1, limit = 50 } = {}) =>
      api(() => apiClient.get("/chat/messages", { params: { room, page, limit } })),

    getChatStatistics: (room = "default") =>
      api(() => apiClient.get("/chat/stats", { params: { room } })),

    getOnlineUsers: () => api(() => apiClient.get("/chat/online")),

    getUserChatHistory: ({ room = "default", page = 1, limit = 20 } = {}) =>
      api(() => apiClient.get("/chat/history", { params: { room, page, limit } })),

    searchMessages: ({ q, room = "default", page = 1, limit = 20 }) =>
      api(() => apiClient.get("/chat/search", { params: { q, room, page, limit } })),

    deleteMessage: (messageId) => api(() => apiClient.delete(`/chat/${messageId}`)),
  },

  xp: {
    getUserXP: () => api(() => apiClient.get("/xp/user")),
    getUserAchievements: () => api(() => apiClient.get("/xp/achievements")),
    getLevelLeaderboard: (limit = 10) => api(() => apiClient.get("/xp/leaderboard/level", { params: { limit } })),
    getWageringLeaderboard: (limit = 10) => api(() => apiClient.get("/xp/leaderboard/wagering", { params: { limit } })),
    getWeeklyWageringLeaderboard: (limit = 10) =>
      api(() => apiClient.get("/xp/leaderboard/weekly-wagering", { params: { limit } })),
    getLeaderboard: (endpoint, limit = 10) => api(() => apiClient.get(endpoint, { params: { limit } })),
    getXPRequirements: (maxLevel = 50) => api(() => apiClient.get("/xp/requirements", { params: { maxLevel } })),
  },

  history: {
    getGameHistory: (filters = {}) => {
      const params = new URLSearchParams();
      if (filters.gameType) params.append("gameType", filters.gameType);
      if (filters.result) params.append("result", filters.result);
      if (filters.startDate) params.append("startDate", filters.startDate);
      if (filters.endDate) params.append("endDate", filters.endDate);
      if (filters.page) params.append("page", String(filters.page));
      if (filters.limit) params.append("limit", String(filters.limit));

      return api(() => apiClient.get(`/game-history/user?${params.toString()}`));
    },

    getGameHistoryStats: (filters = {}) => {
      const params = new URLSearchParams();
      if (filters.gameType) params.append("gameType", filters.gameType);
      if (filters.startDate) params.append("startDate", filters.startDate);
      if (filters.endDate) params.append("endDate", filters.endDate);

      return api(() => apiClient.get(`/game-history/user/stats?${params.toString()}`));
    },

    getDailyStats: (days = 30) => api(() => apiClient.get("/game-history/user/daily-stats", { params: { days } })),
  },

  payment: {
    createPaymentUser: () => api(() => apiClient.post("/payment/user/create")),
    createWallet: (chainId, tokenId) => api(() => apiClient.post("/payment/user/wallet", { chainId, tokenId })),
    getWalletAddresses: (chainIds) => api(() => apiClient.get("/payment/user/wallets", { params: chainIds ? { chainIds } : {} })),
    processWithdrawal: (data) => api(() => apiClient.post("/payment/user/withdraw", data)),
    getTransactions: (params = {}) => api(() => apiClient.get("/payment/user/transactions", { params })),
    getTransactionStats: () => api(() => apiClient.get("/payment/user/stats")),
    getSupportedAssets: () => api(() => apiClient.get("/payment/assets")),
  },

  gameStatus: {
    getActivePlayerCounts: () => api(() => apiClient.get("/game-status/active-players")),
    getGamePlayerCount: (gameType) => api(() => apiClient.get(`/game-status/active-players/${gameType}`)),
  },

  featureTrading: {
    getMarkets: () => api(() => apiClient.get("/feature-trading/markets")),
    getMarketData: (symbol) => api(() => apiClient.get(`/feature-trading/markets/${symbol}`)),
    getPriceHistory: (symbol, timeframe = "1m", limit = 200) =>
      api(() => apiClient.get(`/feature-trading/markets/${symbol}/history`, { params: { timeframe, limit } })),
    getPositions: (symbol) => api(() => apiClient.get("/feature-trading/positions", { params: symbol ? { symbol } : {} })),
    openPosition: (data) => api(() => apiClient.post("/feature-trading/positions/open", data)),
    closePosition: (positionId) => api(() => apiClient.post(`/feature-trading/positions/${positionId}/close`)),
    getStats: () => api(() => apiClient.get("/feature-trading/stats")),
  },
};

export { apiClient };
